/**
 * Cross-Implementation Interop Tests for SPQR
 *
 * Validates that the TypeScript @bcts/spqr package produces wire-compatible
 * GF16 arithmetic, polynomial erasure coding, chain key derivation, V1Msg
 * wire format, protobuf serialization, and version negotiation matching
 * Signal's Rust SPQR crate (v1.4.0).
 *
 * Test vectors generated by /tests/generate_vectors.rs with seed=42.
 *
 * NOTE: The TS implementation uses simulated incremental ML-KEM-768 (not
 * real libcrux), so KEM ciphertext bytes differ. Full cross-implementation
 * message exchange is NOT possible, but structural/format compatibility IS
 * testable across all the areas covered below.
 */

import { describe, it, expect } from 'vitest';
import { readFileSync } from 'node:fs';
import { resolve } from 'node:path';

// GF16 arithmetic
import { GF16 } from '../src/encoding/gf.js';

// Polynomial erasure coding
import { PolyEncoder } from '../src/encoding/polynomial.js';

// Chain key derivation
import { Chain } from '../src/chain.js';
import { Direction, Version } from '../src/types.js';

// V1Msg wire format
import { deserializeMessage } from '../src/v1/chunked/message.js';

// Protobuf encoder/decoder
import {
  decodePqRatchetState,
  encodePqRatchetState,
} from '../src/proto/index.js';

// Top-level API
import {
  initialState,
  currentVersion,
  emptyState,
  type Params,
} from '../src/index.js';

// ---------------------------------------------------------------------------
// Load test vectors
// ---------------------------------------------------------------------------

const FIXTURES_DIR = resolve(
  '/Users/custodio/Development/BCTS/typescript/packages/spqr/tests/fixtures',
);

const vectors = JSON.parse(
  readFileSync(resolve(FIXTURES_DIR, 'rust-vectors.json'), 'utf-8'),
);

// ---------------------------------------------------------------------------
// Hex helpers
// ---------------------------------------------------------------------------

function hexToBytes(hex: string): Uint8Array {
  if (hex.length === 0) return new Uint8Array(0);
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    bytes[i / 2] = parseInt(hex.substring(i, i + 2), 16);
  }
  return bytes;
}

function bytesToHex(bytes: Uint8Array): string {
  return Array.from(bytes)
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('');
}

// ---------------------------------------------------------------------------
// Helper: common auth key and chain params from vectors
// ---------------------------------------------------------------------------

const AUTH_KEY = hexToBytes(vectors.chain.auth_key_hex);
const CHAIN_PARAMS = {
  maxJump: vectors.chain.chain_params.max_jump,
  maxOooKeys: vectors.chain.chain_params.max_ooo_keys,
};

// =========================================================================
// 1. GF(2^16) Arithmetic -- match Rust gf.rs
// =========================================================================

describe('Interop: GF(2^16) arithmetic', () => {
  describe('addition (XOR)', () => {
    const addVectors: [number, number, number][] = vectors.gf16.add;

    it.each(addVectors.map((v, i) => ({ a: v[0], b: v[1], expected: v[2], i })))(
      'add[$i]: GF16($a) + GF16($b) = GF16($expected)',
      ({ a, b, expected }) => {
        const result = new GF16(a).add(new GF16(b));
        expect(result.value).toBe(expected);
      },
    );

    it(`should match all ${addVectors.length} Rust addition vectors`, () => {
      for (const [a, b, expected] of addVectors) {
        expect(new GF16(a).add(new GF16(b)).value).toBe(expected);
      }
    });
  });

  describe('multiplication', () => {
    const mulVectors: [number, number, number][] = vectors.gf16.mul;

    it.each(mulVectors.map((v, i) => ({ a: v[0], b: v[1], expected: v[2], i })))(
      'mul[$i]: GF16($a) * GF16($b) = GF16($expected)',
      ({ a, b, expected }) => {
        const result = new GF16(a).mul(new GF16(b));
        expect(result.value).toBe(expected);
      },
    );

    it(`should match all ${mulVectors.length} Rust multiplication vectors`, () => {
      for (const [a, b, expected] of mulVectors) {
        expect(new GF16(a).mul(new GF16(b)).value).toBe(expected);
      }
    });
  });

  describe('division', () => {
    const divVectors: [number, number, number][] = vectors.gf16.div;

    it.each(divVectors.map((v, i) => ({ a: v[0], b: v[1], expected: v[2], i })))(
      'div[$i]: GF16($a) / GF16($b) = GF16($expected)',
      ({ a, b, expected }) => {
        if (b === 0) {
          expect(() => new GF16(a).div(new GF16(b))).toThrow();
        } else {
          const result = new GF16(a).div(new GF16(b));
          expect(result.value).toBe(expected);
        }
      },
    );

    it(`should match all ${divVectors.length} Rust division vectors`, () => {
      for (const [a, b, expected] of divVectors) {
        if (b === 0) continue; // skip division by zero
        expect(new GF16(a).div(new GF16(b)).value).toBe(expected);
      }
    });
  });

  describe('cross-operation identities', () => {
    it('a * b / b = a for non-zero b', () => {
      const mulVectors: [number, number, number][] = vectors.gf16.mul;
      for (const [a, b] of mulVectors) {
        if (a === 0 || b === 0) continue;
        const product = new GF16(a).mul(new GF16(b));
        const quotient = product.div(new GF16(b));
        expect(quotient.value).toBe(a);
      }
    });

    it('a + b + b = a for all test pairs', () => {
      const addVectors: [number, number, number][] = vectors.gf16.add;
      for (const [a, b] of addVectors) {
        const sum = new GF16(a).add(new GF16(b));
        const original = sum.add(new GF16(b));
        expect(original.value).toBe(a);
      }
    });
  });
});

// =========================================================================
// 2. Polynomial Erasure Coding -- match Rust polynomial.rs
// =========================================================================

describe('Interop: Polynomial erasure coding', () => {
  const encodeDecode: Array<{
    input_hex: string;
    chunks: Array<{ index: number; data_hex: string }>;
  }> = vectors.polynomial.encode_decode;

  for (const tc of encodeDecode) {
    describe(`input: ${tc.input_hex.substring(0, 24)}...`, () => {
      const input = hexToBytes(tc.input_hex);

      it('should produce correct first N+2 chunks matching Rust', () => {
        const encoder = PolyEncoder.encodeBytes(input);

        for (const expected of tc.chunks) {
          const chunk = encoder.nextChunk();
          expect(chunk.index).toBe(expected.index);
          expect(bytesToHex(chunk.data)).toBe(expected.data_hex);
        }
      });

      it('chunks should be deterministic (same input = same output)', () => {
        const enc1 = PolyEncoder.encodeBytes(input);
        const enc2 = PolyEncoder.encodeBytes(input);

        for (let i = 0; i < tc.chunks.length; i++) {
          const c1 = enc1.nextChunk();
          const c2 = enc2.nextChunk();
          expect(c1.index).toBe(c2.index);
          expect(bytesToHex(c1.data)).toBe(bytesToHex(c2.data));
        }
      });
    });
  }

  it('chunk data size is always 32 bytes', () => {
    for (const tc of encodeDecode) {
      const input = hexToBytes(tc.input_hex);
      const encoder = PolyEncoder.encodeBytes(input);

      for (let i = 0; i < 5; i++) {
        const chunk = encoder.nextChunk();
        expect(chunk.data.length).toBe(32);
      }
    }
  });
});

// =========================================================================
// 3. Chain Key Derivation -- match Rust chain.rs
// =========================================================================

describe('Interop: Chain key derivation', () => {
  const chainVectors = vectors.chain;

  it('should have matching auth key', () => {
    expect(bytesToHex(AUTH_KEY)).toBe(chainVectors.auth_key_hex);
  });

  describe('epoch 0 (no additional secret)', () => {
    it('send keys match Rust for epoch 0', () => {
      const chain = Chain.create(AUTH_KEY, Direction.A2B, CHAIN_PARAMS);

      for (const expected of chainVectors.epoch0_send_keys) {
        const [index, key] = chain.sendKey(0n);
        expect(index).toBe(expected.index);
        expect(bytesToHex(key)).toBe(expected.key_hex);
      }
    });

    it('recv keys match Rust for epoch 0 (B-side perspective)', () => {
      // The Rust epoch0_recv_keys represent B-side receiver keys.
      // B has direction B2A; its recv chain uses the A2B HKDF slice,
      // matching A's send keys. So we create a B2A chain.
      const chain = Chain.create(AUTH_KEY, Direction.B2A, CHAIN_PARAMS);

      for (const expected of chainVectors.epoch0_recv_keys) {
        const key = chain.recvKey(0n, expected.index);
        expect(bytesToHex(key)).toBe(expected.key_hex);
      }
    });

    it('A send keys equal B recv keys (cross-party symmetric in epoch 0)', () => {
      // A sends using A2B direction, B receives using B2A direction
      // B's recv chain uses the A2B slice, matching A's send chain
      const aChain = Chain.create(AUTH_KEY, Direction.A2B, CHAIN_PARAMS);
      const bChain = Chain.create(AUTH_KEY, Direction.B2A, CHAIN_PARAMS);

      for (let i = 0; i < chainVectors.epoch0_send_keys.length; i++) {
        const [sendIdx, sendKey] = aChain.sendKey(0n);
        const recvKey = bChain.recvKey(0n, sendIdx);
        expect(bytesToHex(sendKey)).toBe(bytesToHex(recvKey));
      }
    });

    it('epoch 0 secret is null (no pre-shared secret)', () => {
      expect(chainVectors.epoch0_secret_hex).toBeNull();
    });
  });

  describe('epoch 1 (with shared secret)', () => {
    it('send keys match Rust for epoch 1', () => {
      const chain = Chain.create(AUTH_KEY, Direction.A2B, CHAIN_PARAMS);

      // Add epoch 1 with the known secret
      const secret = hexToBytes(chainVectors.epoch1_secret_hex);
      chain.addEpoch({ epoch: 1n, secret });

      for (const expected of chainVectors.epoch1_send_keys) {
        const [index, key] = chain.sendKey(1n);
        expect(index).toBe(expected.index);
        expect(bytesToHex(key)).toBe(expected.key_hex);
      }
    });

    it('recv keys match Rust for epoch 1 (B-side perspective)', () => {
      // The Rust vectors for epoch1_recv_keys are from the B-side receiver.
      // B has direction B2A; its recv chain uses the A2B HKDF slice,
      // matching A's send keys. So we create a B2A chain.
      const chain = Chain.create(AUTH_KEY, Direction.B2A, CHAIN_PARAMS);

      const secret = hexToBytes(chainVectors.epoch1_secret_hex);
      chain.addEpoch({ epoch: 1n, secret });

      for (const expected of chainVectors.epoch1_recv_keys) {
        const key = chain.recvKey(1n, expected.index);
        expect(bytesToHex(key)).toBe(expected.key_hex);
      }
    });

    it('epoch 1 secret matches expected value', () => {
      const expected = chainVectors.epoch1_secret_hex;
      expect(expected).toBe(
        '6363636363636363636363636363636363636363636363636363636363636363',
      );
    });

    it('cross-epoch: epoch 0 and 1 produce different key streams', () => {
      const chain = Chain.create(AUTH_KEY, Direction.A2B, CHAIN_PARAMS);

      // Get epoch 0 first key
      const [, epoch0Key] = chain.sendKey(0n);

      // Add epoch 1
      const secret = hexToBytes(chainVectors.epoch1_secret_hex);
      chain.addEpoch({ epoch: 1n, secret });

      // Get epoch 1 first key
      const [, epoch1Key] = chain.sendKey(1n);

      // They should be different
      expect(bytesToHex(epoch0Key)).not.toBe(bytesToHex(epoch1Key));
    });
  });

  describe('chain parameter validation', () => {
    it('default chain params match Rust defaults', () => {
      expect(CHAIN_PARAMS.maxJump).toBe(25000);
      expect(CHAIN_PARAMS.maxOooKeys).toBe(2000);
    });

    it('direction A2B matches Rust encoding', () => {
      expect(chainVectors.direction).toBe('A2B');
      expect(Direction.A2B).toBe(0);
    });
  });
});

// =========================================================================
// 4. V1Msg Wire Format -- match Rust serialize.rs
// =========================================================================

describe('Interop: V1Msg custom binary wire format', () => {
  const v1msgVectors = vectors.v1msg;
  const messages: Array<{
    sender: string;
    msg_hex: string;
    msg_len: number;
    has_key: boolean;
  }> = v1msgVectors.messages;

  it('auth key matches', () => {
    expect(v1msgVectors.auth_key_hex).toBe(
      '2929292929292929292929292929292929292929292929292929292929292929',
    );
  });

  for (let i = 0; i < messages.length; i++) {
    const msg = messages[i];

    describe(`message ${i}: sender=${msg.sender}`, () => {
      it(`has expected length ${msg.msg_len}`, () => {
        const bytes = hexToBytes(msg.msg_hex);
        expect(bytes.length).toBe(msg.msg_len);
      });

      it('starts with version byte 0x01 (V1)', () => {
        const bytes = hexToBytes(msg.msg_hex);
        expect(bytes[0]).toBe(1);
      });

      it('can be deserialized by TS deserializeMessage', () => {
        const bytes = hexToBytes(msg.msg_hex);
        const result = deserializeMessage(bytes);

        // Should parse without error
        expect(result).toBeDefined();
        expect(result.msg).toBeDefined();
        expect(result.msg.epoch).toBeTypeOf('bigint');
        expect(result.msg.payload).toBeDefined();
      });

      it('round-trips through TS serialize/deserialize', () => {
        const bytes = hexToBytes(msg.msg_hex);
        const { msg: parsed, index } = deserializeMessage(bytes);

        // We cannot round-trip via serializeMessage because it takes a
        // Message + index (not a raw wire format). However, we can verify
        // that the deserialized data is consistent.
        expect(parsed.epoch).toBeGreaterThanOrEqual(0n);
        expect(index).toBeGreaterThanOrEqual(0);
      });

      if (msg.msg_len > 4) {
        it('has chunk payload for chunk-carrying messages', () => {
          const bytes = hexToBytes(msg.msg_hex);
          const { msg: parsed } = deserializeMessage(bytes);

          // Messages longer than 4 bytes must have a chunk
          expect(parsed.payload.type).not.toBe('none');
          expect(parsed.payload.type).not.toBe('ct1Ack');
        });
      }
    });
  }

  it('A sender messages have epoch=1', () => {
    for (const msg of messages.filter((m) => m.sender === 'A')) {
      const bytes = hexToBytes(msg.msg_hex);
      const { msg: parsed } = deserializeMessage(bytes);
      expect(parsed.epoch).toBe(1n);
    }
  });

  it('B sender message has no chunk data (None type during early exchange)', () => {
    const bMsgs = messages.filter((m) => m.sender === 'B');
    expect(bMsgs.length).toBeGreaterThan(0);

    for (const msg of bMsgs) {
      const bytes = hexToBytes(msg.msg_hex);
      const { msg: parsed } = deserializeMessage(bytes);
      // B messages during early exchange (before EK received) are None type
      // Wire format: [version=01][epoch=01][index=01][msgType=00]
      expect(parsed.payload.type).toBe('none');
    }
  });

  it('message deserialization handles varint epoch correctly', () => {
    // All messages have epoch 1 encoded as varint [0x01]
    for (const msg of messages) {
      const bytes = hexToBytes(msg.msg_hex);
      const { msg: parsed } = deserializeMessage(bytes);
      expect(parsed.epoch).toBe(1n);
    }
  });
});

// =========================================================================
// 5. Protobuf State Serialization -- match Rust prost encoding
// =========================================================================

describe('Interop: Protobuf state serialization', () => {
  const protoVectors = vectors.protobuf;

  describe('V0 empty state', () => {
    it('V0 state is empty bytes', () => {
      expect(protoVectors.v0_state_hex).toBe('');
    });

    it('emptyState() returns empty bytes', () => {
      const state = emptyState();
      expect(state.length).toBe(0);
    });
  });

  describe('initial A2B state', () => {
    const stateHex = protoVectors.initial_state_a2b_hex;
    const stateLen = protoVectors.initial_state_a2b_len;

    it(`has expected length ${stateLen}`, () => {
      const bytes = hexToBytes(stateHex);
      expect(bytes.length).toBe(stateLen);
    });

    it('can be decoded by TS decodePqRatchetState', () => {
      const bytes = hexToBytes(stateHex);
      const state = decodePqRatchetState(bytes);

      expect(state).toBeDefined();
      // Rust initial state has versionNegotiation (field 1) and v1 (field 3)
      expect(state.versionNegotiation).toBeDefined();
      expect(state.v1).toBeDefined();
    });

    it('has correct version negotiation fields', () => {
      const bytes = hexToBytes(stateHex);
      const state = decodePqRatchetState(bytes);
      const vn = state.versionNegotiation!;

      expect(bytesToHex(vn.authKey)).toBe(
        '2929292929292929292929292929292929292929292929292929292929292929',
      );
      expect(vn.direction).toBe(Direction.A2B);
      expect(vn.minVersion).toBe(Version.V1);
    });

    it('has V1 inner state (keysUnsampled)', () => {
      const bytes = hexToBytes(stateHex);
      const state = decodePqRatchetState(bytes);

      expect(state.v1).toBeDefined();
      expect(state.v1!.innerState).toBeDefined();
      expect(state.v1!.innerState!.type).toBe('keysUnsampled');
    });

    it('round-trips through TS encode/decode', () => {
      const bytes = hexToBytes(stateHex);
      const decoded = decodePqRatchetState(bytes);
      const reencoded = encodePqRatchetState(decoded);
      const redecoded = decodePqRatchetState(reencoded);

      // Structural equality (not byte-level, due to epoch storage difference)
      expect(redecoded.versionNegotiation).toBeDefined();
      expect(redecoded.v1).toBeDefined();
      expect(redecoded.v1!.innerState!.type).toBe(
        decoded.v1!.innerState!.type,
      );
    });
  });

  describe('initial B2A state', () => {
    const stateHex = protoVectors.initial_state_b2a_hex;
    const stateLen = protoVectors.initial_state_b2a_len;

    it(`has expected length ${stateLen}`, () => {
      const bytes = hexToBytes(stateHex);
      expect(bytes.length).toBe(stateLen);
    });

    it('can be decoded by TS decodePqRatchetState', () => {
      const bytes = hexToBytes(stateHex);
      const state = decodePqRatchetState(bytes);

      expect(state).toBeDefined();
      expect(state.versionNegotiation).toBeDefined();
      expect(state.v1).toBeDefined();
    });

    it('has B2A direction in version negotiation', () => {
      const bytes = hexToBytes(stateHex);
      const state = decodePqRatchetState(bytes);
      const vn = state.versionNegotiation!;

      expect(vn.direction).toBe(Direction.B2A);
    });

    it('B2A state is larger than A2B state', () => {
      // B2A initial state includes receiving decoder, making it larger
      const b2aBytes = hexToBytes(stateHex);
      const a2bBytes = hexToBytes(protoVectors.initial_state_a2b_hex);
      expect(b2aBytes.length).toBeGreaterThan(a2bBytes.length);
    });

    it('B2A state has noHeaderReceived inner state', () => {
      const bytes = hexToBytes(stateHex);
      const state = decodePqRatchetState(bytes);

      expect(state.v1).toBeDefined();
      expect(state.v1!.innerState).toBeDefined();
      // B side starts in noHeaderReceived (waiting for header from A)
      expect(state.v1!.innerState!.type).toBe('noHeaderReceived');
    });
  });

  describe('TS-generated initial states', () => {
    it('A2B initialState produces decodable state', () => {
      const params: Params = {
        direction: Direction.A2B,
        version: Version.V1,
        minVersion: Version.V1,
        authKey: AUTH_KEY,
        chainParams: CHAIN_PARAMS,
      };

      const state = initialState(params);
      expect(state.length).toBeGreaterThan(0);

      const decoded = decodePqRatchetState(state);
      expect(decoded.versionNegotiation).toBeDefined();
      expect(decoded.v1).toBeDefined();
      expect(decoded.v1!.innerState!.type).toBe('keysUnsampled');
    });

    it('B2A initialState produces decodable state', () => {
      const params: Params = {
        direction: Direction.B2A,
        version: Version.V1,
        minVersion: Version.V1,
        authKey: AUTH_KEY,
        chainParams: CHAIN_PARAMS,
      };

      const state = initialState(params);
      expect(state.length).toBeGreaterThan(0);

      const decoded = decodePqRatchetState(state);
      expect(decoded.versionNegotiation).toBeDefined();
      expect(decoded.v1).toBeDefined();
      expect(decoded.v1!.innerState!.type).toBe('noHeaderReceived');
    });
  });
});

// =========================================================================
// 6. Version Negotiation -- match Rust current_version behavior
// =========================================================================

describe('Interop: Version negotiation', () => {
  const vnCases: Array<{
    description: string;
    state_hex: string;
    current_version: {
      type: string;
      version: number;
      min_version?: number;
    };
  }> = vectors.version_negotiation.cases;

  for (const tc of vnCases) {
    describe(tc.description, () => {
      it('should match Rust currentVersion output', () => {
        const stateBytes = hexToBytes(tc.state_hex);
        const result = currentVersion(stateBytes);

        expect(result.type).toBe(tc.current_version.type);

        if (result.type === 'negotiation_complete') {
          expect(result.version).toBe(tc.current_version.version);
        } else {
          expect(result.version).toBe(tc.current_version.version);
          expect(result.minVersion).toBe(tc.current_version.min_version);
        }
      });

      if (tc.state_hex.length > 0) {
        it('state can be decoded as PqRatchetState', () => {
          const bytes = hexToBytes(tc.state_hex);
          const state = decodePqRatchetState(bytes);
          expect(state).toBeDefined();
        });
      }
    });
  }

  it('V0 empty state has negotiation_complete/V0', () => {
    const result = currentVersion(new Uint8Array(0));
    expect(result).toEqual({
      type: 'negotiation_complete',
      version: Version.V0,
    });
  });

  it('fresh V1 A2B state with min_version=V1 is still_negotiating', () => {
    const params: Params = {
      direction: Direction.A2B,
      version: Version.V1,
      minVersion: Version.V1,
      authKey: AUTH_KEY,
      chainParams: CHAIN_PARAMS,
    };
    const state = initialState(params);
    const result = currentVersion(state);
    expect(result.type).toBe('still_negotiating');
    if (result.type === 'still_negotiating') {
      expect(result.version).toBe(Version.V1);
      expect(result.minVersion).toBe(Version.V1);
    }
  });

  it('fresh V1 A2B state with min_version=V0 is still_negotiating', () => {
    const params: Params = {
      direction: Direction.A2B,
      version: Version.V1,
      minVersion: Version.V0,
      authKey: AUTH_KEY,
      chainParams: CHAIN_PARAMS,
    };
    const state = initialState(params);
    const result = currentVersion(state);
    expect(result.type).toBe('still_negotiating');
    if (result.type === 'still_negotiating') {
      expect(result.version).toBe(Version.V1);
      expect(result.minVersion).toBe(Version.V0);
    }
  });
});

// =========================================================================
// 7. Issue 1275 Pre-baked States -- structural decode validation
// =========================================================================

describe('Interop: Issue 1275 pre-baked states', () => {
  const issue1275 = vectors.issue1275;

  describe('A state (headerSent)', () => {
    it(`has expected size ${issue1275.a_state.size}`, () => {
      const bytes = readFileSync(
        resolve(FIXTURES_DIR, 'issue1275_a_state.bin'),
      );
      expect(bytes.length).toBe(issue1275.a_state.size);
    });

    it('decodes without error', () => {
      const bytes = readFileSync(
        resolve(FIXTURES_DIR, 'issue1275_a_state.bin'),
      );
      const state = decodePqRatchetState(new Uint8Array(bytes));
      expect(state).toBeDefined();
      expect(issue1275.a_state.decodes_ok).toBe(true);
    });

    it('has chain (no version negotiation)', () => {
      const bytes = readFileSync(
        resolve(FIXTURES_DIR, 'issue1275_a_state.bin'),
      );
      const state = decodePqRatchetState(new Uint8Array(bytes));

      expect(state.chain).toBeDefined();
      expect(state.versionNegotiation).toBeUndefined();
      expect(issue1275.a_state.has_chain).toBe(true);
      expect(issue1275.a_state.has_version_negotiation).toBe(false);
    });

    it(`has inner state type "${issue1275.a_state.inner_state_type}"`, () => {
      const bytes = readFileSync(
        resolve(FIXTURES_DIR, 'issue1275_a_state.bin'),
      );
      const state = decodePqRatchetState(new Uint8Array(bytes));

      expect(state.v1).toBeDefined();
      expect(state.v1!.innerState).toBeDefined();
      expect(state.v1!.innerState!.type).toBe(
        issue1275.a_state.inner_state_type,
      );
    });

    it('headerSent state has sendingEk encoder and receivingCt1 decoder', () => {
      const bytes = readFileSync(
        resolve(FIXTURES_DIR, 'issue1275_a_state.bin'),
      );
      const state = decodePqRatchetState(new Uint8Array(bytes));
      const inner = state.v1!.innerState!;

      if (inner.type === 'headerSent') {
        expect(inner.sendingEk).toBeDefined();
        expect(inner.receivingCt1).toBeDefined();
        expect(inner.uc).toBeDefined();
      }
    });
  });

  describe('B state (ct1Sampled)', () => {
    it(`has expected size ${issue1275.b_state.size}`, () => {
      const bytes = readFileSync(
        resolve(FIXTURES_DIR, 'issue1275_b_state.bin'),
      );
      expect(bytes.length).toBe(issue1275.b_state.size);
    });

    it('decodes without error', () => {
      const bytes = readFileSync(
        resolve(FIXTURES_DIR, 'issue1275_b_state.bin'),
      );
      const state = decodePqRatchetState(new Uint8Array(bytes));
      expect(state).toBeDefined();
      expect(issue1275.b_state.decodes_ok).toBe(true);
    });

    it('has chain (no version negotiation)', () => {
      const bytes = readFileSync(
        resolve(FIXTURES_DIR, 'issue1275_b_state.bin'),
      );
      const state = decodePqRatchetState(new Uint8Array(bytes));

      expect(state.chain).toBeDefined();
      expect(state.versionNegotiation).toBeUndefined();
    });

    it(`has inner state type "${issue1275.b_state.inner_state_type}"`, () => {
      const bytes = readFileSync(
        resolve(FIXTURES_DIR, 'issue1275_b_state.bin'),
      );
      const state = decodePqRatchetState(new Uint8Array(bytes));

      expect(state.v1).toBeDefined();
      expect(state.v1!.innerState).toBeDefined();
      expect(state.v1!.innerState!.type).toBe(
        issue1275.b_state.inner_state_type,
      );
    });

    it('ct1Sampled state has sendingCt1 encoder and receivingEk decoder', () => {
      const bytes = readFileSync(
        resolve(FIXTURES_DIR, 'issue1275_b_state.bin'),
      );
      const state = decodePqRatchetState(new Uint8Array(bytes));
      const inner = state.v1!.innerState!;

      if (inner.type === 'ct1Sampled') {
        expect(inner.sendingCt1).toBeDefined();
        expect(inner.receivingEk).toBeDefined();
        expect(inner.uc).toBeDefined();
      }
    });
  });

  it('A and B states have different inner state types', () => {
    expect(issue1275.a_state.inner_state_type).not.toBe(
      issue1275.b_state.inner_state_type,
    );
  });

  it('B state (with decoder+encoder) is larger than A state', () => {
    expect(issue1275.b_state.size).toBeGreaterThan(issue1275.a_state.size);
  });
});

// =========================================================================
// 8. Proto field number alignment -- verify TS encodes at correct fields
// =========================================================================

describe('Interop: Proto field number alignment', () => {
  describe('chunked state field numbers match Rust proto schema', () => {
    // The Rust proto defines:
    //   NoHeaderReceived: uc=1, receiving_hdr=2
    //   HeaderReceived:   uc=1, receiving_ek=2
    //   Ct1Acknowledged:  uc=1, receiving_ek=2
    //   EkSentCt1Received: uc=1, receiving_ct2=3  (skips field 2)
    //
    // After fix, TS should encode decoder at field 2 for the first three,
    // and field 3 for EkSentCt1Received.

    it('noHeaderReceived encodes decoder at field 2', () => {
      const params: Params = {
        direction: Direction.B2A,
        version: Version.V1,
        minVersion: Version.V1,
        authKey: AUTH_KEY,
        chainParams: CHAIN_PARAMS,
      };
      const state = initialState(params);
      const decoded = decodePqRatchetState(state);

      // B2A starts in noHeaderReceived
      expect(decoded.v1!.innerState!.type).toBe('noHeaderReceived');

      // Re-encode and decode to verify field alignment
      const reencoded = encodePqRatchetState(decoded);
      const redecoded = decodePqRatchetState(reencoded);

      expect(redecoded.v1!.innerState!.type).toBe('noHeaderReceived');
      if (redecoded.v1!.innerState!.type === 'noHeaderReceived') {
        expect(redecoded.v1!.innerState!.receivingHdr).toBeDefined();
      }
    });

    it('Rust-generated B2A state decodes noHeaderReceived correctly', () => {
      const b2aHex = vectors.protobuf.initial_state_b2a_hex;
      const bytes = hexToBytes(b2aHex);
      const state = decodePqRatchetState(bytes);

      expect(state.v1!.innerState!.type).toBe('noHeaderReceived');
      if (state.v1!.innerState!.type === 'noHeaderReceived') {
        // After the field number fix, the decoder data (at proto field 2)
        // should be correctly read as receivingHdr
        expect(state.v1!.innerState!.receivingHdr).toBeDefined();
      }
    });
  });

  describe('V1State oneof field mapping', () => {
    const stateTypes = [
      { field: 1, type: 'keysUnsampled' },
      { field: 2, type: 'keysSampled' },
      { field: 3, type: 'headerSent' },
      { field: 4, type: 'ct1Received' },
      { field: 5, type: 'ekSentCt1Received' },
      { field: 6, type: 'noHeaderReceived' },
      { field: 7, type: 'headerReceived' },
      { field: 8, type: 'ct1Sampled' },
      { field: 9, type: 'ekReceivedCt1Sampled' },
      { field: 10, type: 'ct1Acknowledged' },
      { field: 11, type: 'ct2Sampled' },
    ];

    it('should have 11 state types mapped to fields 1-11', () => {
      expect(stateTypes.length).toBe(11);
      for (let i = 0; i < stateTypes.length; i++) {
        expect(stateTypes[i].field).toBe(i + 1);
      }
    });
  });
});

// =========================================================================
// 9. HKDF label consistency
// =========================================================================

describe('Interop: HKDF label consistency', () => {
  it('Chain Start label has double space', () => {
    // This is a critical interop requirement -- the label must have
    // two spaces before "Start" to match the Rust implementation
    const label = 'Signal PQ Ratchet V1 Chain  Start';
    expect(label).toContain('  Start');
    expect(label).not.toContain('   Start');
  });

  it('Chain Add Epoch label matches', () => {
    const label = 'Signal PQ Ratchet V1 Chain Add Epoch';
    expect(label.length).toBe(36);
  });

  it('Chain Next label matches', () => {
    const label = 'Signal PQ Ratchet V1 Chain Next';
    expect(label.length).toBe(31);
  });
});

// =========================================================================
// 10. Test vector metadata
// =========================================================================

describe('Interop: Test vector metadata', () => {
  it('vectors were generated by spqr-rust-v1.4.0', () => {
    expect(vectors.generated_by).toBe('spqr-rust-v1.4.0');
  });

  it('vectors use seed 42', () => {
    expect(vectors.seed).toBe(42);
  });

  it('has all expected sections', () => {
    expect(vectors.gf16).toBeDefined();
    expect(vectors.polynomial).toBeDefined();
    expect(vectors.chain).toBeDefined();
    expect(vectors.protobuf).toBeDefined();
    expect(vectors.v1msg).toBeDefined();
    expect(vectors.version_negotiation).toBeDefined();
    expect(vectors.issue1275).toBeDefined();
  });

  it('GF16 has 20 vectors per operation', () => {
    expect(vectors.gf16.add.length).toBe(20);
    expect(vectors.gf16.mul.length).toBe(20);
    expect(vectors.gf16.div.length).toBe(20);
  });
});
