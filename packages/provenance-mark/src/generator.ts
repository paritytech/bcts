// Ported from provenance-mark-rust/src/generator.rs

import { toBase64, fromBase64, bytesToHex } from "@blockchain-commons/components";
import { type Cbor } from "@blockchain-commons/dcbor";

import { ProvenanceMarkError, ProvenanceMarkErrorType } from "./error.js";
import { type ProvenanceMarkResolution, linkLength } from "./resolution.js";
import { ProvenanceSeed } from "./seed.js";
import { RngState } from "./rng-state.js";
import { sha256 } from "./crypto-utils.js";
import { Xoshiro256StarStar } from "./xoshiro256starstar.js";
import { ProvenanceMark } from "./mark.js";

/**
 * Generator for creating provenance mark chains.
 */
export class ProvenanceMarkGenerator {
  private _res: ProvenanceMarkResolution;
  private _seed: ProvenanceSeed;
  private _chainId: Uint8Array;
  private _nextSeq: number;
  private _rngState: RngState;

  private constructor(
    res: ProvenanceMarkResolution,
    seed: ProvenanceSeed,
    chainId: Uint8Array,
    nextSeq: number,
    rngState: RngState,
  ) {
    this._res = res;
    this._seed = seed;
    this._chainId = chainId;
    this._nextSeq = nextSeq;
    this._rngState = rngState;
  }

  res(): ProvenanceMarkResolution {
    return this._res;
  }

  seed(): ProvenanceSeed {
    return this._seed;
  }

  chainId(): Uint8Array {
    return new Uint8Array(this._chainId);
  }

  nextSeq(): number {
    return this._nextSeq;
  }

  rngState(): RngState {
    return this._rngState;
  }

  /**
   * Create a new generator with a seed.
   */
  static newWithSeed(res: ProvenanceMarkResolution, seed: ProvenanceSeed): ProvenanceMarkGenerator {
    // Definitely don't use the bare seed as the chain ID!
    const digest1 = sha256(seed.toBytes());
    const chainId = digest1.slice(0, linkLength(res));
    const digest2 = sha256(digest1);
    return ProvenanceMarkGenerator.new(res, seed, chainId, 0, RngState.fromBytes(digest2));
  }

  /**
   * Create a new generator with a passphrase.
   */
  static newWithPassphrase(
    res: ProvenanceMarkResolution,
    passphrase: string,
  ): ProvenanceMarkGenerator {
    const seed = ProvenanceSeed.newWithPassphrase(passphrase);
    return ProvenanceMarkGenerator.newWithSeed(res, seed);
  }

  /**
   * Create a new generator with custom random data.
   */
  static newUsing(res: ProvenanceMarkResolution, randomData: Uint8Array): ProvenanceMarkGenerator {
    const seed = ProvenanceSeed.newUsing(randomData);
    return ProvenanceMarkGenerator.newWithSeed(res, seed);
  }

  /**
   * Create a new generator with random seed.
   */
  static newRandom(res: ProvenanceMarkResolution): ProvenanceMarkGenerator {
    const seed = ProvenanceSeed.new();
    return ProvenanceMarkGenerator.newWithSeed(res, seed);
  }

  /**
   * Create a new generator with all parameters.
   */
  static new(
    res: ProvenanceMarkResolution,
    seed: ProvenanceSeed,
    chainId: Uint8Array,
    nextSeq: number,
    rngState: RngState,
  ): ProvenanceMarkGenerator {
    const linkLen = linkLength(res);
    if (chainId.length !== linkLen) {
      throw new ProvenanceMarkError(ProvenanceMarkErrorType.InvalidChainIdLength, undefined, {
        expected: linkLen,
        actual: chainId.length,
      });
    }
    return new ProvenanceMarkGenerator(res, seed, chainId, nextSeq, rngState);
  }

  /**
   * Generate the next provenance mark in the chain.
   */
  next(date: Date, info?: Cbor): ProvenanceMark {
    const data = this._rngState.toBytes();
    let rng = Xoshiro256StarStar.fromData(data);

    const seq = this._nextSeq;
    this._nextSeq += 1;

    let key: Uint8Array;
    if (seq === 0) {
      key = new Uint8Array(this._chainId);
    } else {
      // The randomness generated by the PRNG should be portable across implementations
      key = rng.nextBytes(linkLength(this._res));
      this._rngState = RngState.fromBytes(rng.toData());
    }

    // Clone the RNG for generating next_key
    const nextRngData = rng.toData();
    const nextRng = Xoshiro256StarStar.fromData(nextRngData);
    const nextKey = nextRng.nextBytes(linkLength(this._res));

    return ProvenanceMark.new(
      this._res,
      key,
      nextKey,
      new Uint8Array(this._chainId),
      seq,
      date,
      info,
    );
  }

  /**
   * String representation.
   */
  toString(): string {
    return `ProvenanceMarkGenerator(chainID: ${bytesToHex(this._chainId)}, res: ${this._res}, seed: ${this._seed.hex()}, nextSeq: ${this._nextSeq})`;
  }

  /**
   * JSON serialization.
   */
  toJSON(): Record<string, unknown> {
    return {
      res: this._res,
      seed: toBase64(this._seed.toBytes()),
      chainID: toBase64(this._chainId),
      nextSeq: this._nextSeq,
      rngState: toBase64(this._rngState.toBytes()),
    };
  }

  /**
   * Create from JSON object.
   */
  static fromJSON(json: Record<string, unknown>): ProvenanceMarkGenerator {
    const res = json.res as ProvenanceMarkResolution;
    const seed = ProvenanceSeed.fromBytes(fromBase64(json.seed as string));
    const chainId = fromBase64(json.chainID as string);
    const nextSeq = json.nextSeq as number;
    const rngState = RngState.fromBytes(fromBase64(json.rngState as string));
    return ProvenanceMarkGenerator.new(res, seed, chainId, nextSeq, rngState);
  }
}
