/**
 * Copyright © 2023-2026 Blockchain Commons, LLC
 * Copyright © 2025-2026 Leonardo Amoroso Custodio
 * Copyright © 2026 Parity Technologies
 */

// Ported from provenance-mark-rust/src/generator.rs

import { toBase64, fromBase64, bytesToHex } from "./utils.js";
import { type Cbor } from "@bcts/dcbor";
import { Envelope } from "@bcts/envelope";

import { ProvenanceMarkError, ProvenanceMarkErrorType } from "./error.js";
import {
  type ProvenanceMarkResolution,
  linkLength,
  resolutionToNumber,
  resolutionFromCbor,
} from "./resolution.js";
import { ProvenanceSeed } from "./seed.js";
import { RngState } from "./rng-state.js";
import { sha256 } from "./crypto-utils.js";
import { Xoshiro256StarStar } from "./xoshiro256starstar.js";
import { ProvenanceMark } from "./mark.js";

/**
 * Generator for creating provenance mark chains.
 */
export class ProvenanceMarkGenerator {
  private readonly _res: ProvenanceMarkResolution;
  private readonly _seed: ProvenanceSeed;
  private readonly _chainId: Uint8Array;
  private _nextSeq: number;
  private _rngState: RngState;

  private constructor(
    res: ProvenanceMarkResolution,
    seed: ProvenanceSeed,
    chainId: Uint8Array,
    nextSeq: number,
    rngState: RngState,
  ) {
    this._res = res;
    this._seed = seed;
    this._chainId = chainId;
    this._nextSeq = nextSeq;
    this._rngState = rngState;
  }

  res(): ProvenanceMarkResolution {
    return this._res;
  }

  seed(): ProvenanceSeed {
    return this._seed;
  }

  chainId(): Uint8Array {
    return new Uint8Array(this._chainId);
  }

  nextSeq(): number {
    return this._nextSeq;
  }

  rngState(): RngState {
    return this._rngState;
  }

  /**
   * Create a new generator with a seed.
   */
  static newWithSeed(res: ProvenanceMarkResolution, seed: ProvenanceSeed): ProvenanceMarkGenerator {
    // Definitely don't use the bare seed as the chain ID!
    const digest1 = sha256(seed.toBytes());
    const chainId = digest1.slice(0, linkLength(res));
    const digest2 = sha256(digest1);
    return ProvenanceMarkGenerator.new(res, seed, chainId, 0, RngState.fromBytes(digest2));
  }

  /**
   * Create a new generator with a passphrase.
   */
  static newWithPassphrase(
    res: ProvenanceMarkResolution,
    passphrase: string,
  ): ProvenanceMarkGenerator {
    const seed = ProvenanceSeed.newWithPassphrase(passphrase);
    return ProvenanceMarkGenerator.newWithSeed(res, seed);
  }

  /**
   * Create a new generator with custom random data.
   */
  static newUsing(res: ProvenanceMarkResolution, randomData: Uint8Array): ProvenanceMarkGenerator {
    const seed = ProvenanceSeed.newUsing(randomData);
    return ProvenanceMarkGenerator.newWithSeed(res, seed);
  }

  /**
   * Create a new generator with random seed.
   */
  static newRandom(res: ProvenanceMarkResolution): ProvenanceMarkGenerator {
    const seed = ProvenanceSeed.new();
    return ProvenanceMarkGenerator.newWithSeed(res, seed);
  }

  /**
   * Create a new generator with all parameters.
   */
  static new(
    res: ProvenanceMarkResolution,
    seed: ProvenanceSeed,
    chainId: Uint8Array,
    nextSeq: number,
    rngState: RngState,
  ): ProvenanceMarkGenerator {
    const linkLen = linkLength(res);
    if (chainId.length !== linkLen) {
      throw new ProvenanceMarkError(ProvenanceMarkErrorType.InvalidChainIdLength, undefined, {
        expected: linkLen,
        actual: chainId.length,
      });
    }
    return new ProvenanceMarkGenerator(res, seed, chainId, nextSeq, rngState);
  }

  /**
   * Generate the next provenance mark in the chain.
   */
  next(date: Date, info?: Cbor): ProvenanceMark {
    const data = this._rngState.toBytes();
    const rng = Xoshiro256StarStar.fromData(data);

    const seq = this._nextSeq;
    this._nextSeq += 1;

    let key: Uint8Array;
    if (seq === 0) {
      key = new Uint8Array(this._chainId);
    } else {
      // The randomness generated by the PRNG should be portable across implementations
      key = rng.nextBytes(linkLength(this._res));
      this._rngState = RngState.fromBytes(rng.toData());
    }

    // Clone the RNG for generating next_key
    const nextRngData = rng.toData();
    const nextRng = Xoshiro256StarStar.fromData(nextRngData);
    const nextKey = nextRng.nextBytes(linkLength(this._res));

    return ProvenanceMark.new(
      this._res,
      key,
      nextKey,
      new Uint8Array(this._chainId),
      seq,
      date,
      info,
    );
  }

  /**
   * String representation.
   */
  toString(): string {
    return `ProvenanceMarkGenerator(chainID: ${bytesToHex(this._chainId)}, res: ${this._res}, seed: ${this._seed.hex()}, nextSeq: ${this._nextSeq})`;
  }

  /**
   * JSON serialization.
   */
  toJSON(): Record<string, unknown> {
    return {
      res: this._res,
      seed: toBase64(this._seed.toBytes()),
      chainID: toBase64(this._chainId),
      nextSeq: this._nextSeq,
      rngState: toBase64(this._rngState.toBytes()),
    };
  }

  /**
   * Create from JSON object.
   */
  static fromJSON(json: Record<string, unknown>): ProvenanceMarkGenerator {
    const res = json["res"] as ProvenanceMarkResolution;
    const seed = ProvenanceSeed.fromBytes(fromBase64(json["seed"] as string));
    const chainId = fromBase64(json["chainID"] as string);
    const nextSeq = json["nextSeq"] as number;
    const rngState = RngState.fromBytes(fromBase64(json["rngState"] as string));
    return ProvenanceMarkGenerator.new(res, seed, chainId, nextSeq, rngState);
  }

  // ============================================================================
  // Envelope Support (EnvelopeEncodable)
  // ============================================================================

  /**
   * Convert this generator to a Gordian Envelope.
   *
   * The envelope contains structured assertions for all generator fields:
   * - isA: "provenance-generator"
   * - res: The resolution
   * - seed: The seed
   * - next-seq: The next sequence number
   * - rng-state: The RNG state
   *
   * Note: Use provenanceMarkGeneratorToEnvelope() for a standalone function alternative.
   */
  intoEnvelope(): Envelope {
    // Create envelope with chain ID as subject
    let envelope = Envelope.new(this._chainId);

    // Add type assertion (using addType() which uses IS_A KnownValue, like Rust's add_type())
    envelope = envelope.addType("provenance-generator");

    // Add resolution
    envelope = envelope.addAssertion("res", resolutionToNumber(this._res));

    // Add seed
    envelope = envelope.addAssertion("seed", this._seed.toBytes());

    // Add next sequence number
    envelope = envelope.addAssertion("next-seq", this._nextSeq);

    // Add RNG state
    envelope = envelope.addAssertion("rng-state", this._rngState.toBytes());

    return envelope;
  }

  /**
   * Extract a ProvenanceMarkGenerator from a Gordian Envelope.
   *
   * @param envelope - The envelope to extract from
   * @returns The extracted generator
   * @throws ProvenanceMarkError if extraction fails
   */
  static fromEnvelope(envelope: Envelope): ProvenanceMarkGenerator {
    type EnvelopeExt = Envelope & {
      asByteString(): Uint8Array | undefined;
      hasType(t: string): boolean;
      assertionsWithPredicate(p: string): Envelope[];
      subject(): Envelope;
    };

    const env = envelope as EnvelopeExt;

    // Check type
    if (!env.hasType("provenance-generator")) {
      throw new ProvenanceMarkError(ProvenanceMarkErrorType.CborError, undefined, {
        message: "Envelope is not a provenance-generator",
      });
    }

    // Extract chain ID from subject
    const subject = env.subject() as EnvelopeExt;
    const chainId = subject.asByteString();
    if (chainId === undefined) {
      throw new ProvenanceMarkError(ProvenanceMarkErrorType.CborError, undefined, {
        message: "Could not extract chain ID",
      });
    }

    // Helper to extract assertion object value
    const extractAssertion = (predicate: string): { cbor: Cbor; bytes: Uint8Array | undefined } => {
      const assertions = env.assertionsWithPredicate(predicate);
      if (assertions.length === 0) {
        throw new ProvenanceMarkError(ProvenanceMarkErrorType.CborError, undefined, {
          message: `Missing ${predicate} assertion`,
        });
      }
      const assertionCase = assertions[0].case();
      if (assertionCase.type !== "assertion") {
        throw new ProvenanceMarkError(ProvenanceMarkErrorType.CborError, undefined, {
          message: `Invalid ${predicate} assertion`,
        });
      }
      const obj = assertionCase.assertion.object() as EnvelopeExt;
      const objCase = obj.case();
      if (objCase.type === "leaf") {
        return { cbor: objCase.cbor, bytes: obj.asByteString() };
      }
      throw new ProvenanceMarkError(ProvenanceMarkErrorType.CborError, undefined, {
        message: `Invalid ${predicate} value`,
      });
    };

    // Extract resolution
    const resValue = extractAssertion("res");
    const res = resolutionFromCbor(resValue.cbor);

    // Extract seed
    const seedValue = extractAssertion("seed");
    if (seedValue.bytes === undefined) {
      throw new ProvenanceMarkError(ProvenanceMarkErrorType.CborError, undefined, {
        message: "Invalid seed data",
      });
    }
    const seed = ProvenanceSeed.fromBytes(seedValue.bytes);

    // Extract next-seq
    const seqValue = extractAssertion("next-seq");
    const nextSeq = Number(seqValue.cbor);

    // Extract rng-state
    const rngValue = extractAssertion("rng-state");
    if (rngValue.bytes === undefined) {
      throw new ProvenanceMarkError(ProvenanceMarkErrorType.CborError, undefined, {
        message: "Invalid rng-state data",
      });
    }
    const rngState = RngState.fromBytes(rngValue.bytes);

    return ProvenanceMarkGenerator.new(res, seed, chainId, nextSeq, rngState);
  }
}
