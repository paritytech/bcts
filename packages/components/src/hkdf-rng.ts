/**
 * A deterministic random number generator based on HKDF-HMAC-SHA256.
 *
 * Ported from bc-components-rust/src/hkdf_rng.rs
 *
 * `HKDFRng` uses the HMAC-based Key Derivation Function (HKDF) to generate
 * deterministic random numbers from a combination of key material and salt. It
 * serves as a key-stretching mechanism that can produce an arbitrary amount of
 * random-looking bytes from a single seed.
 *
 * Since it produces deterministic output based on the same inputs, it's useful
 * for situations where repeatable randomness is required, such as in testing
 * or when deterministically deriving keys from a master seed.
 *
 * Security considerations:
 * - The security of the generator depends on the entropy and secrecy of the
 *   key material
 * - The same key material and salt will always produce the same sequence
 * - Use a secure random seed for cryptographic applications
 * - Never reuse the same HKDFRng instance for different purposes
 *
 * The implementation automatically handles buffer management, fetching new
 * data using HKDF as needed with an incrementing counter to ensure unique
 * output for each request.
 *
 * @example
 * ```typescript
 * import { HKDFRng } from '@bcts/components';
 *
 * // Create an HKDF-based RNG
 * const rng = HKDFRng.new(new TextEncoder().encode("my secure seed"), "wallet-derivation");
 *
 * // Generate two u32 values
 * const random1 = rng.nextU32();
 * const random2 = rng.nextU32();
 *
 * // The same seed and salt will always produce the same sequence
 * const rng2 = HKDFRng.new(new TextEncoder().encode("my secure seed"), "wallet-derivation");
 * console.log(random1 === rng2.nextU32()); // true
 * console.log(random2 === rng2.nextU32()); // true
 * ```
 */

import { hkdfHmacSha256 } from "@bcts/crypto";
import type { RandomNumberGenerator } from "@bcts/rand";

const DEFAULT_PAGE_LENGTH = 32;

/**
 * A deterministic random number generator based on HKDF-HMAC-SHA256.
 *
 * Implements the RandomNumberGenerator interface from @bcts/rand.
 */
export class HKDFRng implements RandomNumberGenerator {
  /** Internal buffer of generated bytes */
  private _buffer: Uint8Array;
  /** Current position in the buffer */
  private _position: number;
  /** Source key material (seed) */
  private readonly _keyMaterial: Uint8Array;
  /** Salt value to combine with the key material */
  private readonly _salt: string;
  /** Length of each "page" of generated data */
  private readonly _pageLength: number;
  /** Current page index */
  private _pageIndex: number;

  private constructor(keyMaterial: Uint8Array, salt: string, pageLength: number) {
    this._buffer = new Uint8Array(0);
    this._position = 0;
    this._keyMaterial = new Uint8Array(keyMaterial);
    this._salt = salt;
    this._pageLength = pageLength;
    this._pageIndex = 0;
  }

  // ============================================================================
  // Static Factory Methods
  // ============================================================================

  /**
   * Creates a new `HKDFRng` with a custom page length.
   *
   * @param keyMaterial - The seed material to derive random numbers from
   * @param salt - A salt value to mix with the key material
   * @param pageLength - The number of bytes to generate in each HKDF call
   * @returns A new `HKDFRng` instance configured with the specified parameters
   */
  static newWithPageLength(keyMaterial: Uint8Array, salt: string, pageLength: number): HKDFRng {
    return new HKDFRng(keyMaterial, salt, pageLength);
  }

  /**
   * Creates a new `HKDFRng` with the default page length of 32 bytes.
   *
   * @param keyMaterial - The seed material to derive random numbers from
   * @param salt - A salt value to mix with the key material
   * @returns A new `HKDFRng` instance configured with the specified key material and salt
   */
  static new(keyMaterial: Uint8Array, salt: string): HKDFRng {
    return HKDFRng.newWithPageLength(keyMaterial, salt, DEFAULT_PAGE_LENGTH);
  }

  // ============================================================================
  // Private Methods
  // ============================================================================

  /**
   * Refills the internal buffer with new deterministic random bytes.
   *
   * This method is called automatically when the internal buffer is exhausted.
   * It uses HKDF-HMAC-SHA256 to generate a new page of random bytes using the
   * key material, salt, and current page index.
   */
  private fillBuffer(): void {
    const saltString = `${this._salt}-${this._pageIndex}`;
    const encoder = new TextEncoder();
    this._buffer = hkdfHmacSha256(this._keyMaterial, encoder.encode(saltString), this._pageLength);
    this._position = 0;
    this._pageIndex += 1;
  }

  /**
   * Generates the specified number of deterministic random bytes.
   *
   * @param length - The number of bytes to generate
   * @returns A Uint8Array containing the requested number of deterministic random bytes
   */
  private nextBytes(length: number): Uint8Array {
    const result: number[] = [];
    while (result.length < length) {
      if (this._position >= this._buffer.length) {
        this.fillBuffer();
      }
      const remaining = length - result.length;
      const available = this._buffer.length - this._position;
      const take = Math.min(remaining, available);
      for (let i = 0; i < take; i++) {
        result.push(this._buffer[this._position + i]);
      }
      this._position += take;
    }
    return new Uint8Array(result);
  }

  // ============================================================================
  // RandomNumberGenerator Implementation
  // ============================================================================

  /**
   * Generates deterministic random bytes.
   *
   * @param length - The number of bytes to generate
   * @returns A Uint8Array of random bytes
   */
  randomData(length: number): Uint8Array {
    return this.nextBytes(length);
  }

  /**
   * Fills the provided buffer with deterministic random bytes.
   *
   * @param dest - The buffer to fill with random bytes
   */
  fillBytes(dest: Uint8Array): void {
    const bytes = this.nextBytes(dest.length);
    dest.set(bytes);
  }

  // ============================================================================
  // Additional Methods (matching Rust RngCore interface)
  // ============================================================================

  /**
   * Generates a random `u32` value.
   *
   * @returns A deterministic random 32-bit unsigned integer
   */
  nextU32(): number {
    const bytes = this.nextBytes(4);
    // Little-endian byte order
    return bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24);
  }

  /**
   * Generates a random `u64` value.
   *
   * Note: JavaScript numbers can only safely represent integers up to 2^53 - 1,
   * so this returns a BigInt for full 64-bit precision.
   *
   * @returns A deterministic random 64-bit unsigned integer as BigInt
   */
  nextU64(): bigint {
    const bytes = this.nextBytes(8);
    // Little-endian byte order
    let result = BigInt(0);
    for (let i = 7; i >= 0; i--) {
      result = (result << BigInt(8)) | BigInt(bytes[i]);
    }
    return result;
  }

  /**
   * Attempts to fill the provided buffer with random bytes.
   * This implementation never fails.
   *
   * @param dest - The buffer to fill with random bytes
   */
  tryFillBytes(dest: Uint8Array): void {
    this.fillBytes(dest);
  }

  // ============================================================================
  // Accessors (for testing)
  // ============================================================================

  /**
   * Returns the key material (for testing purposes).
   */
  getKeyMaterial(): Uint8Array {
    return new Uint8Array(this._keyMaterial);
  }

  /**
   * Returns the salt (for testing purposes).
   */
  getSalt(): string {
    return this._salt;
  }

  /**
   * Returns the page length (for testing purposes).
   */
  getPageLength(): number {
    return this._pageLength;
  }

  /**
   * Returns the current page index (for testing purposes).
   */
  getPageIndex(): number {
    return this._pageIndex;
  }
}
